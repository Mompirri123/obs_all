**Model A**
Flow of how termination handling is applied (functions, parameters, call chain)
1. `smallpond.init()` creates `Session(...)` and then defines `_handle_termination_signal(signum, frame)` inside `smallpond.__init__.py`.
2. `smallpond.init()` registers the handler with `signal.signal(signal.SIGTERM, _handle_termination_signal)` and `signal.signal(signal.SIGINT, _handle_termination_signal)`.
3. `_handle_termination_signal()` sets `session._terminated = True`, then calls `signal.signal(signum, signal.SIG_DFL)` and `signal.raise_signal(signum)`.
4. `atexit.register(session.shutdown)` is already called in `smallpond.init()`, so `Session.shutdown()` should run on normal interpreter exit.
5. `Session.shutdown()` in `smallpond.dataframe.Session` now checks `finished = self._all_tasks_finished()` and `terminated = self._terminated`.
6. `Session.shutdown()` writes `terminated` to `job_status_path` when `terminated` is `True` and skips `RuntimeContext.cleanup(remove_output_root=self.config.remove_output_root)`.

New or modified functions/parameters
- Modified `smallpond.init()` to register SIGTERM/SIGINT handlers and to use `_handle_termination_signal()`.
- New inner function `_handle_termination_signal(signum, frame)` in `smallpond.__init__.py`.
- Modified `Session.__init__()` in `smallpond.dataframe.Session` to add `self._terminated`.
- Modified `Session.shutdown()` in `smallpond.dataframe.Session` to set status `terminated` and to skip cleanup when `self._terminated` is `True`.
- No new public parameters were added. The only new state is the private flag `Session._terminated`.

Tests added/changed and what they prove
- `tests/test_session.py::test_shutdown_no_cleanup_on_termination` sets `Session._terminated = True` and verifies `queue_root`, `staging_root`, `temp_root`, and a temp file remain after `Session.shutdown()`. This proves `Session.shutdown()` respects `Session._terminated` and does not call `RuntimeContext.cleanup(...)`.
- `tests/test_session.py::test_shutdown_no_cleanup_on_termination_with_partial_output` creates files under `staging_root` and verifies they remain after `Session.shutdown()` with `Session._terminated = True`. This proves partial outputs in `staging_root` are preserved when `Session._terminated` is set.
- `tests/test_session.py::test_terminated_flag_prevents_cleanup_even_when_tasks_finished` completes tasks, sets `Session._terminated = True`, and verifies no cleanup and status `terminated`. This proves `Session._terminated` overrides `finished` status.
- Edge cases not covered: real SIGTERM/SIGINT handling (no `os.kill()` test), multiple sessions overriding signal handlers, and termination while tasks are still running in Ray.

Pros
- Matches the prompt intent if the requirement is to keep partial outputs on termination. This is enforced in `Session.shutdown()` by checking `self._terminated` and skipping `RuntimeContext.cleanup(remove_output_root=...)`.
- Adds a clear status label `terminated` in `Session.shutdown()` written to `job_status_path`, which can help post-run inspection.
- Tests explicitly check preservation of `staging_root` and `temp_root` under termination using `Session._terminated`.

Cons
- `smallpond.init()` changes global signal handling with `signal.signal(...)` and does not restore any previous handler. This can break callers that already set SIGTERM/SIGINT handlers.
- `_handle_termination_signal()` resets the handler to `signal.SIG_DFL` and then calls `signal.raise_signal(signum)`. This can bypass `atexit.register(session.shutdown)` and can prevent `Session.shutdown()` from running at all, so `job_status_path` might never get a `terminated` entry.
- The new logic depends on the private flag `Session._terminated`. There is no public API like `Session.shutdown(terminated=True)` or `Session.terminate()`.
- Tests set `Session._terminated` directly and do not validate that `signal.signal(...)` actually triggers the flag in a live process.

PR readiness for Model A
- Not ready. The signal flow in `smallpond.init()` and `_handle_termination_signal()` is likely to skip `Session.shutdown()` in real SIGTERM/SIGINT cases.

Concrete next-turn fixes for Model A
1. Replace `signal.raise_signal(signum)` with a clean shutdown path. Example: set `Session._terminated = True`, call `Session.shutdown()` explicitly, then call `sys.exit(128 + signum)` to let `atexit` run.
2. Store previous handlers from `signal.getsignal(...)` and restore or chain them instead of overriding silently.
3. Add a test that spawns a subprocess running `smallpond.init()` and sends SIGTERM to verify `job_status_path` contains `terminated` and directories are preserved.
4. Consider adding a public method like `Session.terminate()` to avoid direct use of `Session._terminated` in tests.

**Model B**
Flow of how cleanup is applied (functions, parameters, call chain)
1. `Session.shutdown()` in `smallpond.dataframe.Session` calls `finished = self._all_tasks_finished()`.
2. If `finished` is `True`, `Session.shutdown()` calls `RuntimeContext.cleanup(remove_output_root=self.config.remove_output_root)`.
3. If `finished` is `False`, `Session.shutdown()` now calls `RuntimeContext.cleanup_partial()`.
4. `RuntimeContext.cleanup_partial()` in `smallpond.execution.task.RuntimeContext` removes `queue_root`, `temp_root`, and `staging_root` via `remove_path(...)`, and leaves `output_root` and `log_root` intact.
5. For individual tasks, `WorkItem.exec()` always calls `Task.cleanup()` in a `finally` block.
6. `Task.cleanup()` now checks `self.status` and calls `_cleanup_partial_output()` when `WorkStatus.FAILED` or `WorkStatus.CRASHED`.
7. `Task._cleanup_partial_output()` removes `runtime_output_abspath` and `temp_abspath` using `remove_path(...)`.

New or modified functions/parameters
- Modified `Session.shutdown()` in `smallpond.dataframe.Session` to call `RuntimeContext.cleanup_partial()` when `finished` is `False`.
- New `RuntimeContext.cleanup_partial()` in `smallpond.execution.task.RuntimeContext`.
- Modified `Task.cleanup()` in `smallpond.execution.task.Task` to call `_cleanup_partial_output()` for `WorkStatus.FAILED` and `WorkStatus.CRASHED`.
- New `Task._cleanup_partial_output()` in `smallpond.execution.task.Task`.
- No new public parameters were added.

Tests added/changed and what they prove
- `tests/test_session.py::test_shutdown_cleanup_partial_on_failure` (renamed from no-cleanup test) now expects `queue_root`, `staging_root`, and `temp_root` to be removed when a task fails. This proves `Session.shutdown()` calls `RuntimeContext.cleanup_partial()` for `finished == False`.
- `tests/test_session.py::test_cleanup_partial_removes_temp_and_staging` builds a `RuntimeContext` and verifies `RuntimeContext.cleanup_partial()` removes `queue_root`, `temp_root`, and `staging_root` while preserving `output_root` and `log_root`.
- `tests/test_session.py::test_task_cleanup_removes_partial_output_on_crash` creates a crashing `Task`, then verifies `Task.cleanup()` removes `runtime_output_abspath` and `temp_abspath` on `WorkStatus.CRASHED`.
- `tests/test_session.py::test_task_cleanup_preserves_output_on_success` verifies `Task.finalize()` keeps `final_output_abspath` on `WorkStatus.SUCCEED` and that `_cleanup_partial_output()` does not run.
- Edge cases not covered: real SIGTERM/SIGINT termination, `WorkStatus.FAILED` path for `_cleanup_partial_output()` (only crash tested), and termination while tasks are still running in Ray.

Pros
- Adds a clear partial cleanup path in `RuntimeContext.cleanup_partial()` with a focused scope (does not remove `output_root`).
- Task-level cleanup in `Task.cleanup()` and `_cleanup_partial_output()` prevents leftover staging and temp output on failures and crashes.
- Tests validate both runtime-context cleanup and task-level cleanup behavior.

Cons
- The prompt is about task termination, but `Session.shutdown()` now removes partial outputs on any unfinished run, including failures, with no termination flag. This can contradict the requirement if outputs should be preserved on termination.
- No signal handling was added in `smallpond.init()` or `Session.shutdown()`, so real SIGTERM/SIGINT termination is not handled explicitly.
- The cleanup happens even on failure, which can remove useful debugging artifacts from `runtime_output_abspath` and `temp_abspath` in `Task._cleanup_partial_output()`.
- Test imports include `TaskId` but it is not used in `tests/test_session.py`.

PR readiness for Model B
- Not ready. It does not implement termination handling, and it may implement the opposite behavior if termination should preserve outputs.

Concrete next-turn fixes for Model B
1. Add a termination flag in `Session.shutdown()` (for example `Session._terminated` or `Session.shutdown(terminated=True)`) and skip `RuntimeContext.cleanup_partial()` when terminated.
2. Add signal handling in `smallpond.init()` to set the termination flag before shutdown, or add a documented `Session.terminate()` method.
3. Add tests that simulate SIGTERM/SIGINT in a subprocess and validate that `staging_root` and `temp_root` are preserved when terminated.
4. Decide if task-level cleanup in `Task._cleanup_partial_output()` should be limited to explicit failure states or controlled by a config flag.

**Comparison Table**
| Question of which is / has | Answer Given | Justification Why? |
| ------------------------------------ | ------------ | ------------------- |
| Overall Better Solution | Model A (+3) | `Session.shutdown()` respects `Session._terminated` and preserves outputs, which matches the requirement if termination should not remove partial outputs. Model B removes outputs in `RuntimeContext.cleanup_partial()` with no termination flag. |
| Better logic and correctness | Model A (+2) | Model A wires a termination state into `Session.shutdown()`. Model B only handles failure, not termination, and can delete partial outputs. |
| Better Naming and Clarity | Model B (-1) | `RuntimeContext.cleanup_partial()` and `Task._cleanup_partial_output()` are clear and self-explanatory, while `Session._terminated` is a private flag with no public API. |
| Better Organization and Clarity | Model A (+1) | Model A limits changes to `smallpond.init()` and `Session.shutdown()`, while Model B spreads logic across `Session.shutdown()`, `RuntimeContext.cleanup_partial()`, and `Task.cleanup()`. |
| Better Interface Design | Model B (-1) | `RuntimeContext.cleanup_partial()` provides a dedicated method, while Model A relies on the private `Session._terminated` flag and global signal handlers. |
| Better error handling and robustness | Tie (0) | Model A tries to handle termination but does not guarantee `Session.shutdown()` runs. Model B is robust for failure cleanup but ignores termination. |
| Better comments and documentation | Tie (0) | Model A adds inline comments in `smallpond.init()`. Model B adds docstrings in `RuntimeContext.cleanup_partial()` and `Task._cleanup_partial_output()`. |
| Ready for review / merge | Model A (+2) | Model A is closer to the termination requirement, but still needs fixes to signal handling. Model B misses termination handling and may violate the requirement. |

**Which model is better and why**
Model A is better because the behavior in `Session.shutdown()` is explicitly gated by `Session._terminated`, so partial outputs and temp directories are preserved when termination is detected. Model B implements cleanup for failure in `RuntimeContext.cleanup_partial()` and `Task._cleanup_partial_output()`, but it does not introduce any termination flow. If the requirement is to preserve outputs on termination, Model B is the wrong behavior. If the requirement is to remove outputs on termination, the prompt should be clarified and Model B should still add a termination flag and signal handling.
