
[[task 16]]
[[task 17]]
[[task 18]]
[[task 19]]
[[task 20]]



| Task file   | PR idea                                                                                        | Likely files          | Est. non-test LOC | User issue it prevents                                                                              |
| ----------- | ---------------------------------------------------------------------------------------------- | --------------------- | ----------------: | --------------------------------------------------------------------------------------------------- |
|             | Path immutability + absolute-path preservation in `Path.load()`/`Path.add()`                   | `furl/furl.py`        |            70–120 | Reused path objects/lists get mutated, causing later URLs to be wrong.                              |
| [[task 16]] | IPv6-safe `origin` setter parsing (`http://[::1]:8080`)                                        | `furl/furl.py`        |            50–100 | Users cannot set IPv6 origins reliably; local/dev/internal URLs fail.                               |
| [[task 19]] | Refactor netloc parsing into a single helper used by `netloc` + `origin` setters               | `furl/furl.py`        |            90–160 | Inconsistent parsing paths create surprising differences between `origin` and `netloc` assignments. |
|             | Per-label IDNA decode/encode support (e.g. `www.xn--...`)                                      | `furl/furl.py`        |            60–130 | Internationalized domains appear inconsistently (encoded in some flows, decoded in others).         |
| [[task 18]] | Strict-mode warning consistency pass (path/query/fragment)                                     | `furl/furl.py`        |           100–180 | Malformed encoded URLs can slip through silently in one component but warn in another.              |
|             | Query parsing strategy cleanup with explicit delimiter handling policy                         | `furl/furl.py`        |            80–150 | Users paste query strings using `;`/mixed delimiters and get unexpected params.                     |
| [[task 17]] | Improve `furl.remove()` overlap handling with warnings for `args/query/query_params` conflicts | `furl/furl.py`        |             40–90 | Removing params in one call can delete more than users intended.                                    |
|             | Canonicalization helper for scheme/netloc edge cases (`''`, `None`, empty host)                | `furl/furl.py`        |            70–140 | Users see odd URL outputs (`://`, `//`) in edge states and can’t predict serialization.             |
|             | `urlsplit`/`urljoin` scheme normalization refactor for uncommon schemes                        | `furl/furl.py`        |           120–200 | Relative joins behave differently across schemes, breaking redirects/builders.                      |
|             | Packaging/test runner alignment (`tox` vs `setup.py test`)                                     | `setup.py`, `tox.ini` |             30–80 | Contributors run different commands and get different outcomes, causing CI confusion.               |
|             | Port parsing hardening (`None`, empty, non-numeric, out-of-range) with consistent validation   | `furl/furl.py`        |             40–90 | Invalid ports silently pass or fail inconsistently, causing bad URLs at runtime.                    |
|             | Username/password encoding normalization (avoid double-encode, keep safe decode rules)         | `furl/furl.py`        |            70–130 | Auth URLs break for special characters or credentials become corrupted after multiple edits.        |
|             | Preserve duplicate query key ordering across `set/add/remove` flows                            | `furl/furl.py`        |            80–150 | APIs relying on repeated params (`a=1&a=2`) behave incorrectly after modifications.                 |
|             | Empty-vs-missing query/fragment serialization policy (`?`, `#`, empty string, `None`)          | `furl/furl.py`        |            60–120 | Users cannot predict whether delimiters are retained, causing cache/signature mismatches.           |
|             | Percent-encoding safety pass for path segments (prevent accidental double-encoding)            | `furl/furl.py`        |            70–140 | Paths become `%252F`-style corrupted after repeated transformations.                                |
|             | Strict handling for invalid percent escapes (`%`, `%G1`) across path/query/fragment            | `furl/furl.py`        |            90–160 | Malformed URLs are accepted and later fail downstream in clients/proxies.                           |
|             | Normalize trailing slash semantics in path manipulations (`/a` vs `/a/`)                       | `furl/furl.py`        |            50–110 | Route-sensitive services receive wrong endpoint paths after path edits.                             |
|             | `join` behavior parity with RFC 3986 for `..`, `.`, and authority transitions                  | `furl/furl.py`        |           120–200 | Relative URL joins produce surprising targets in redirect/build flows.                              |
|             | Improve copy/deepcopy behavior so component edits never leak between instances                 | `furl/furl.py`        |            50–100 | Cloned URLs unexpectedly mutate each other in request builders.                                     |
|             | Better error messages with actionable context (component name + offending value)               | `furl/furl.py`        |             40–90 | Debugging malformed user input is slow because exceptions lack useful detail.                       |
|             | Add a canonical `normalize()` API (scheme/host case, default ports, encoding normalization)    | `furl/furl.py`        |           120–220 | Equivalent URLs compare as different strings, causing dedupe/cache misses.                          |
|             | Add explicit query delimiter policy switch (`&` only vs `&` + `;`)                             | `furl/furl.py`        |            70–130 | Teams ingest mixed query formats and get inconsistent argument parsing across environments.         |
Nice direction. Here are **enhancement-only** rows you can append:

| Task file   | PR idea                                                                                    | Likely files             | Est. non-test LOC | User issue it prevents                                                                  |
| ----------- | ------------------------------------------------------------------------------------------ | ------------------------ | ----------------: | --------------------------------------------------------------------------------------- |
|             | Fluent immutable API (`with_scheme()`, `with_host()`, `with_path()`) returning new objects | `furl/furl.py`           |           120–220 | Chained URL building currently encourages mutation and makes shared-state bugs easier.  |
|             | Batch update API (`update_components(...)`) with one-shot validation/serialization         | `furl/furl.py`           |            90–170 | Multi-step edits create intermediate invalid states and extra parsing overhead.         |
|             | Query schema helpers (typed get/set for int/bool/list with defaults)                       | `furl/furl.py`           |            80–160 | App code repeatedly reimplements query coercion and defaults inconsistently.            |
|             | Stable serialization profiles (`canonical`, `preserve_input_order`)                        | `furl/furl.py`           |           100–180 | Teams need deterministic URL output for signatures, cache keys, and snapshots.          |
|             | URL template expansion helper (light RFC6570-style path/query placeholders)                | `furl/furl.py`           |           140–240 | Users hand-roll string formatting for URLs and introduce encoding mistakes.             |
|             | Relative URL generation API (`relative_to(base)`)                                          | `furl/furl.py`           |            90–170 | Clients need compact links and currently implement brittle custom diff logic.           |
| [[task 20]] | Path segment editing utilities (`insert`, `replace`, `pop`, slice ops)                     | `furl/furl.py`           |            70–140 | Segment-level edits require awkward manual list manipulation.                           |
|             | Host display mode option (Unicode vs punycode output)                                      | `furl/furl.py`           |            60–120 | Different consumers want readable hosts vs wire-safe hosts without manual conversion.   |
|             | URL comparison helper (`equivalent_to`) with configurable normalization rules              | `furl/furl.py`           |           100–190 | Equality checks based on raw strings create false mismatches for equivalent URLs.       |
|             | Component-level diff utility (`diff(other)`) for scheme/host/path/query/fragment           | `furl/furl.py`           |            80–150 | Debugging URL transformation pipelines is hard without structured before/after insight. |
|             | Parse/serialize micro-cache for repeated read-only access patterns                         | `furl/furl.py`           |            90–170 | High-throughput code repeatedly recomputes derived parts, adding avoidable overhead.    |
|             | Developer diagnostics mode (`explain()` dump of normalized components)                     | `furl/furl.py`, `docs/*` |            60–120 | Troubleshooting odd URL behavior is slow without a built-in structured inspection view. |